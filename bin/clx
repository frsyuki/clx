#!/usr/bin/env ruby

begin
require 'rubygems'
rescue Exception
end
require 'msgpack/rpc'
require 'clx/default'
require 'clx/addr'

TIMEOUT = 5.0
DOT_CLX = ENV['CLX_INFO'] || ENV['HOME']+"/.clx"


def connect_manager
	begin
		mgr_host = nil
		mgr_port = nil
		conf_name = nil
		File.open(DOT_CLX) {|f|
			mgr_host = f.gets.strip
			mgr_port = f.gets.to_i
			conf_name = f.gets.strip
		}
	rescue
		puts "#{DOT_CLX} does not exist. run `#{$0} config <manager[:port]>` first."
		exit 1
	end

	c = MessagePack::RPC::Client.new(mgr_host, mgr_port)
	c.timeout = TIMEOUT
	c
end

	
def write_dot_clx(mgr_addr, conf_name)
	mgr_host, mgr_port = mgr_addr.strip.split(':',2)
	mgr_port ||= CLX::MANAGER_DEFAULT_PORT
	
	File.open(DOT_CLX, "w") {|f|
		f.puts(mgr_host)
		f.puts(mgr_port)
		f.puts(conf_name.strip)
	}

	puts "saved #{DOT_CLX}"
end


def show_result(req)
	if req.error
		puts req.error.to_s
	elsif req.result.is_a?(String)
		puts req.result
	else
		puts req.result.inspect
	end
end


matches = []
matches_i = 0
ARGV.each {|arg|
	key, match = arg.split("=",2)
	break unless match
	matches.push [key, match]
	matches_i += 1
}
ARGV.slice!(0,matches_i)


if ARGV[0] == "-h" || ARGV[0] == "--help"
	puts "Usage #{File.basename($0)} [key=match ...] <command> [args...]"
	exit 1
end


if ARGV[0] == "config"
	ARGV.shift
	mgr = ARGV.shift
	conf_name = ARGV.shift || "default"
	conf_name = ARGV.shift || "default"
	if !mgr || !ARGV.empty?
		puts "Usage #{File.basename($0)} config <manager[:port]> [config-name=default]"
		exit 1
	end

	write_dot_clx(mgr, conf_name)

=begin
	usage = <<USAGE
Usage #{File.basename($0)} config -m <manager[:port]> [config-name=default]"
      #{File.basename($0)} config key value"
      #{File.basename($0)} config key"
USAGE


	if ARGV[0] == "-h" || ARGV[0] == "--help"
		puts usage
		exit 1
	end

	if ARGV[0] == "-m" || ARGV[0] == "--manager"
		ARGV.shift

		mgr = ARGV.shift
		conf_name = ARGV.shift || "default"
		if !mgr || !ARGV.empty?
			puts usage
			exit 1
		end

		write_dot_clx(mgr, conf_name)
		exit 0
	end

	case ARGV.length
	when 1
		c = connect_manager
		req = c.send(:getconfig, ARGV[0]).join
		show_result(req)

	when 2
		c = connect_manager
		req = c.send(:setconfig, ARGV[0], ARGV[1]).join
		show_result(req)

	else
		puts usage
		exit 1
	end
=end

	exit 0
end


c = connect_manager
agents = c.call(:agents)
c.close


lo = MessagePack::RPC::Loop.new

## check matches
agents = agents.map do |addr, hostname|
	host, port = Address.parse(addr)
	client = MessagePack::RPC::Client.new(host, port, lo)
	client.timeout = TIMEOUT

	reqs = matches.map {|key, match|
		req = client.send(:get, key)
		[ req, match ]
	}

	[client, hostname, reqs]
end

agents.map! do |client, hostname, reqs|
	values = reqs.map {|req, match|
		req.join
		result = req.result  # ignore req.error
		[ result, match ]
	}
	[ client, hostname, values ]
end


def check_match_num_range(str, exp)
	m = /(.*?)\[\[([0-9\-\,]+)\]\](.*)/.match(exp)
	unless m
		return str == exp
	end

	prefix  = m[1]
	filelds = m[2].split(',')
	suffix  = m[3]

	ok = false
	filelds.each do |f|
		m = /([0-9]+)(?:\-([0-9]+))/.match(f)
		if m[2]  # x-y
			from  = m[1].to_i
			to    = m[2].to_i
			zeros = m[2].scan(/\A0+/)[0]
		else  # y
			from  = f.to_i
			to    = f.to_i
			zeros = f.scan(/\A0+/)[0]
		end

		(from..to).each {|i|
			if "#{prefix}#{zeros}#{i}#{suffix}" == str
				ok = true
				break
			end
		}
		break if ok
	end

	return ok
end

def check_match(result, exp)
	case result
	when NilClass
		return false

	when Array
		ok = false
		result.each {|r|
			if check_match(r, exp)
				ok = true
			else
				ok = false
				break
			end
		}
		return ok

	when String
		return check_match_num_range(result, exp)

	else
		return false
	end
end

agents.reject! do |client, hostname, values|
	remove = false
	values.each {|result, match|
		unless check_match(result, match)
			remove = true
			break
		end
	}
	remove
end


if ARGV.empty?
	agents.each do |client, hostname, req|
		puts "#{hostname}\t#{client.host}:#{client.port}"
	end
	exit 0
end


argv = ARGV.map {|a|
	if a == '-'
		STDIN.read
	else
		a
	end
}

agents.map! do |client, hostname, _|
	req = client.send(*argv)
	[client, hostname, req]
end

agents.each do |client, hostname, req|
	req.join
	puts "#{hostname}:\t#{client.host}:#{client.port}"
	print "   ";  show_result(req)
	puts ""
end

